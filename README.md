# РК2 по ТФЯ 
## Вариант 18

## задача 1:

<img width="1280" height="683" alt="image" src="https://github.com/user-attachments/assets/0ede7b5e-d00d-405f-845b-8c234e34f046" />

<img width="1280" height="895" alt="image" src="https://github.com/user-attachments/assets/7b86fed2-4b52-4942-8da4-9788e3d4a21c" />

<img width="1220" height="1280" alt="image" src="https://github.com/user-attachments/assets/f766c913-1f89-47d0-bad2-840f8422f0dd" />

<img width="1022" height="1280" alt="image" src="https://github.com/user-attachments/assets/f3492329-aae0-4665-b40a-f2c9e5432d43" />

<img width="1280" height="376" alt="image" src="https://github.com/user-attachments/assets/24d77df9-48c4-4f19-8773-29b805f93546" />

<img width="1280" height="816" alt="image" src="https://github.com/user-attachments/assets/33c7cbfe-2e4d-4474-9ae5-a51188be885d" />

<img width="1264" height="1280" alt="image" src="https://github.com/user-attachments/assets/9700d97e-cb88-4746-9621-5276e8a81f69" />


# задача 2:
Рассматривается язык

L = { w<sub>1</sub> a<sup>n</sup> w<sub>2</sub> | |w<sub>1</sub>|<sub>a</sub> = |w<sub>2</sub>|<sub>b</sub>  и  w<sub>1</sub> не содержит подслово aa },<br>

где w<sub>1</sub>, w<sub>2</sub> ∈ {a, b}<sup>*</sup>, n ≥ 0.<br>

Из теории, для доказательста что L - КС, достаточно построить недетерминированный магазинный автомат (НПДА), распознающий L.<br>
Тогда построим НПДА для нашего L.

<img width="1483" height="556" alt="image" src="https://github.com/user-attachments/assets/f3461a50-64ad-41cd-a194-b205573cf6f7" />

Проверка принадлежности слову из L состоит из двух частей:

1. Условие “w1 не содержит aa” — локальное: достаточно помнить, был ли предыдущий символ равен a.
Это реализуется через сосотояния q0 и q1 .

2. Условие равенства |w1|<sub>a</sub> = |w2|<sub>b</sub> — это баланс “количество a в первой части” равно “количество b в последней части”. 
Для этого используется стек:
- в начале стека лежит маркер дна ⊥, обозначающий конец стека.
- за каждую букву a, прочитанную в w1, кладём маркер A в стек;
- за каждую букву b, прочитанную в w2, снимаем один маркер A со стека;
- в конце стек должен вернуться к ⊥. 

Т.к. границы разбиения w = w1 a^n w2 заранее неизвестны (в слове нет разделителей), то автомат недетерминированно выбирает границы с помощью переходов без чтения входа (ε-переходов).<br>
Таким образом наш автомат получая на вход слово, одновременно проверяет все возможные разбиения слова, и если одно из условий нарушается то ветка это разбиения заершается, если из всех возможных разбиений хотябы одно достигает состояния qAcc, то атомат принимает слово.<br>
Действительно если хотябы одно из разбиений слова удовлетворет условиям, то оно принадлежит языку.
Опишем Конструкцию НПДА

Входной алфавит: {a, b} <br>
Алфавит стека: {⊥, A}, где ⊥ — маркер дна стека. <br>

Состояния: <br>
q0   — читаем w1, предыдущий символ не равен a (или начало слова) <br>
q1   — читаем w1, предыдущий символ равен a (контроль запрета aa) <br>
qM   — читаем середину a^n <br>
q2   — читаем w2 <br>
qACC — принимающее состояние <br>

Если слово принято, значит существует ветка вычисления, где автомат выбрал разбиение w = w1 a^n w2.
В фазе w1 запрет aa обеспечен отсутствием перехода по a из q1.
Каждая a в w1 добавляет один A в стек.
В фазе w2 каждая b снимает один A, а принять можно только при возврате к ⊥.
Следовательно, |w1|<sub>a</sub> = |w2|<sub>b</sub>, и слово удовлетворяет определению L.

Если слово принадлежит L, то существует корректное разбиение w = w1 a^n w2.
Автомат недетерминированно выбирает границы именно в этих позициях,
затем корректно проверяет отсутствие aa в w1 и баланс стека между a в w1 и b в w2,
поэтому существует принимающая ветка.
Следовательно, слово будет принято.

Итак, язык L распознаётся НПДА, значит L является контекстно-свободным.

Теперь проверим язык на детерминизм.

Рассмотрим регулярный язык
R = (ab)* aa b*.
Положим K = L ∩ R.

Любое слово из R имеет вид w = (ab)<sup>t</sup> aa b<sup>m</sup>, t,m ≥ 0.
Так как w<sub>1</sub> не должно содержать подслово aa, граница между w<sub>1</sub> и a<sup>n</sup> в словах из R может проходить относительно блока “aa” только двумя способами:

w<sub>1</sub> = (ab)<sup>t</sup>, тогда a<sup>n</sup> = aa (то есть n = 2), w<sub>2</sub> = b<sup>m</sup> и условие |w<sub>1</sub>|<sub>a</sub> = |w<sub>2</sub>|<sub>b</sub> даёт m = t.

w<sub>1</sub> = (ab)<sup>t</sup>a, тогда a<sup>n</sup> = a (то есть n = 1), w<sub>2</sub> = b<sup>m</sup> и условие даёт m = t+1.

Следовательно,
K = { (ab)<sup>t</sup> aa b<sup>t</sup> | t ≥ 0 } ∪ { (ab)<sup>t</sup> aa b<sup>t+1</sup> | t ≥ 0 }.

Предположим, что L ∈ DCFL. Тогда и K ∈ DCFL, поскольку класс DCFL замкнут относительно пересечения с регулярными языками.

Покажем, что K не может быть распознан никаким ДПМА. Рассмотрим момент чтения первой ‘a’ из блока “aa” после префикса (ab)<sup>t</sup>. Для принятия слова (ab)<sup>t</sup> aa b<sup>t</sup> автомат должен интерпретировать эту ‘a’ как принадлежащую середине a<sup>n</sup> (не увеличивать счётчик |w<sub>1</sub>|<sub>a</sub>), а для принятия (ab)<sup>t</sup> aa b<sup>t+1</sup> — как принадлежащую w<sub>1</sub> (увеличить |w<sub>1</sub>|<sub>a</sub> на 1). Эти два требования взаимоисключающие, а после “aa” остаются только символы b, поэтому “исправить” выбор позже невозможно. Значит, детерминированный автомат не может принимать обе семьи слов, то есть K ∉ DCFL.

Получили противоречие. Следовательно, L ∉ DCFL, то есть язык L не детерминизируем.

