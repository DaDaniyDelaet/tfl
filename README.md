# ЛР4 Кравец Данил ИУ9-51б Вариант 18

## Дано расширенное регулярное выражение

^(?=b+a(?:a|bba|bbba)* b * $ )(bb|b(a\1)|a\1\2)*$ <br>

Алфавит: {a, b}. Строка принадлежит языку если одновременно выполняются: <br>
1) опережающая проверка (?= ... ) (lookahead),
2) основной шаблон (bb|b(a\1)|a\1\2)*,
где вся строка целиком ограничена якорями начала ^ и конца $.

## 1. Внешнее ограничение (lookahead)

Опережающая проверка задаёт условие:

b+ a (a | bba | bbba)* b*

То есть строка должна начинаться с b+ (один или больше символ b), затем содержать символ a, <br>
далее содержать ноль или больше блоков из множества { a, bba, bbba }, <br>
и завершаться хвостом b* (ноль или больше символов b) до конца строки. <br>

Значит после первой a внутри части (a | bba | bbba)* перед следующей a может быть только 0, 2 или 3 символа b , и шаблон "aba" (одна b между двумя a) внутри этой области невозможен.

## 2. Основной шаблон и инициализация захватов

Основная часть выражения:

(bb | b(a\1) | a\1\2)*

Группа захвата \1 — это вся скобка (bb | b(a\1) | a\1\2).
Внутри второй альтернативы присутствует группа захвата \2 = (a\1).

По семантике из условия (нестандартные расширенные регулярные выражения) на первом проходе выбираются альтернативы, на которых выражение может инициализироваться; ветви, требующие ссылок на ещё неинициализированные группы, использовать нельзя.

Следовательно в самом начале невозможно выбрать альтернативы b(a\1) и a\1\2, так как они содержат \1, значит первый выбранный блок обязан быть bb.

После первого блока будет \1 = "bb".

Для визуализации синтаксической структуры основной части `(bb|b(a\1)|a\1\2)*` построено дерево разбора (AST) с помощью regextocfg.ru.

<img width="548" height="476" alt="image" src="https://github.com/user-attachments/assets/6605f638-b3da-4da4-be2b-704dba629da3" />

## 3. символ a в рамках основного шаблона

Чтобы пройти lookahead, в строке обязана присутствовать хотя бы одна буква a. Блок bb её не содержит, поэтому хотя бы один раз должна быть выбрана альтернатива:

b(a\1)

При текущем \1 = "bb" получаем:
- \2 = a\1 = "abb",
- весь блок = "b" + "abb" = "babb".

После этого:
- \1 = "babb",
- \2 = "abb".

Таким образом, появление первой буквы a в слове, распознаваемом основным шаблоном, возможно через блок "babb".

После порождения блока "babb" в слове уже появилась буква a. Проверим, что произойдёт, если после этого попытаться снова выбрать альтернативы, порождающие a.

### 4.1. Повторный выбор b(a\1)

Если \1 = "babb", то:
- a\1 = "ababb",
- блок b(a\1) = "b" + "ababb" = "bababb".

Внутри "bababb" встречается подстрока "aba" , где между двумя a ровно один b, что противоречит ограничению lookahead (после первой a допускаются только 0, 2 или 3 b перед следующей a). Следовательно, после появления первой a выбирать b(a\1) нельзя.

### 4.2. Выбор a\1\2

Если \1 = "babb" и \2 = "abb", то:
- блок a\1\2 = "a" + "babb" + "abb" = "ababbabb".

В начале "ababbabb" присутствует подстрока "aba" (одна b между a), что также противоречит ограничению lookahead. Следовательно, после появления первой a выбирать a\1\2 нельзя.

### 4.3. Остаётся единственная альтернатива

Единственная альтернатива, не добавляющая новых a, — это bb. Её можно повторять произвольно много раз.

## 5. Итоговая структура допустимых слов

Из предыдущих пунктовв следует, что любые слова языка имеют строго следующую форму: <br>
сначала некоторое число блоков bb (минимум один, чтобы инициализировать \1), затем ровно один блок babb (чтобы в слове появилась буква a), и некоторое число блоков bb (возможно ноль).

Формально: <br>

L = { (bb)^k · (babb) · (bb)^m | k >= 1, m >= 0 } <br>

Эквивалентная запись по степеням b: <br>

L = { b^(2k+1) a b^(2m+2) | k >= 1, m >= 0 } <br>

## 6. Примеры

Принадлежат языку: <br>
 k=1, m=0: bbbabb = bbb a bb <br>
 k=2, m=0: bbbbbabb = bbbbb a bb <br>
 k=1, m=1: bbbabbbb = bbb a bbbb <br>

Не принадлежат языку: <br>
 bb (нет символа a, не проходит lookahead) <br>
 babb (невозможно начать с babb: \1 не инициализирована, первый блок должен быть bb) <br>
 любые слова, где после первой a появляется "aba" внутри области, ограниченной lookahead <br>
## Анализ языка на КС-свойство и регулярность

Из п.5 получили явная структура языка: <br>

L = { (bb)^k · (babb) · (bb)^m | k >= 1, m >= 0 }. <br>

Это описание задаётся обычным регулярным выражением без обратных ссылок и lookahead, например: <br>

(bb)+ babb (bb)* <br>

Следовательно язык L является регулярным. Так как любой регулярный язык является контекстно-свободным, то язык также обладает КС-свойством. <br>

Знаичит язык регулярныйи КС.

##  Наивный парсер (рекурсивный разбор с возвратами)

По лекциям под парсером понимается процедура сопоставления строки с выражением, которая перебирает альтернативы и при необходимости откатывается (backtracking). У нас парсер проверяет принадлежность строки языку L.

тогда для наивного парсера: <br>
1) Сначала проверяется ограничение lookahead: строка должна иметь вид b+ a (a|bba|bbba)* b*. <br> 
2) Затем разбирается основная часть (bb|b(a\1)|a\1\2)* как последовательность блоков, выбирая в каждой позиции одну из альтернатив и делая возврат при неуспехе. <br>

Чтобы парсер не зацикливался (требование условия), в обработке оператора * используем правило: если очередная итерация не продвинула позицию во входной строке, повтор прекращается. У нас  блоки имеют положительную длину (bb или babb), поэтому это условие выполняется автоматически, но мы все равно зафиксируем правило как часть алгоритма.

С учётом структуры языка из п.5 наивный разбор удобно формулировать как рекурсивный перебор разбиений на допустимые блоки:
 допускаемые блоки: "bb" и "babb"; <br>
 обязательное условие: встретить ровно один блок "babb"; <br>
 перед первым "babb" должно быть хотя бы одно "bb". <br>

Функция go(pos, seen_a) пытается разобрать суффикс строки, начиная с позиции pos: <br>
если pos == |s|: успех тогда и только тогда, когда seen_a = true, иначе пробуем: <br>
   взять "bb" (если подходит) и перейти в go(pos+2, seen_a), <br>
   взять "babb" (если подходит и seen_a = false) и перейти в go(pos+4, true), <br>
   при неуспехе откатываемся и пробуем другую ветку. <br>

Результатом парсера будут true/false.

##  Оптимизированный парсер и оценка сложности сверху

Оптимизация строится на явной форме слов языка: <br>

L = { b^(2k+1) a b^(2m+2) | k >= 1, m >= 0 }. <br>

Получили линейную проверку: <br>

1) В строке ровно один символ 'a'. 
2) Все символы слева от 'a' — это 'b', их количество нечётное и не меньше 3.
3) Все символы справа от 'a' — это 'b', их количество чётное и не меньше 2.

Каждый шаг требует один проход по строке, поэтому вычислительная сложность сверху:
- по времени: O(n),
- по памяти: O(1),
где n = |s|.

## Проверка эквивалентности парсеров и сравнение скорости

Для фазз-тестирования генерируются два пула строк над алфавитом {a, b}:
 ускорение на OUT = T_naive(OUT) / T_opt(OUT).

