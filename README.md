# РК2 по ТФЯ 
## Вариант 18

## задача 1:

<img width="1280" height="683" alt="image" src="https://github.com/user-attachments/assets/0ede7b5e-d00d-405f-845b-8c234e34f046" />

<img width="1280" height="895" alt="image" src="https://github.com/user-attachments/assets/7b86fed2-4b52-4942-8da4-9788e3d4a21c" />

<img width="1220" height="1280" alt="image" src="https://github.com/user-attachments/assets/f766c913-1f89-47d0-bad2-840f8422f0dd" />

<img width="1022" height="1280" alt="image" src="https://github.com/user-attachments/assets/f3492329-aae0-4665-b40a-f2c9e5432d43" />

<img width="1280" height="376" alt="image" src="https://github.com/user-attachments/assets/24d77df9-48c4-4f19-8773-29b805f93546" />

<img width="1280" height="816" alt="image" src="https://github.com/user-attachments/assets/33c7cbfe-2e4d-4474-9ae5-a51188be885d" />

<img width="1264" height="1280" alt="image" src="https://github.com/user-attachments/assets/9700d97e-cb88-4746-9621-5276e8a81f69" />


# задача 2:
Рассматривается язык

L = { w<sub>1</sub> a<sup>n</sup> w<sub>2</sub> | |w<sub>1</sub>|<sub>a</sub> = |w<sub>2</sub>|<sub>b</sub>  и  w<sub>1</sub> не содержит подслово aa },<br>

где w<sub>1</sub>, w<sub>2</sub> ∈ {a, b}<sup>*</sup>, n ≥ 0.<br>

Из теории, для доказательста что L - КС, достаточно построить недетерминированный магазинный автомат (НПДА), распознающий L.<br>
Тогда построим НПДА для нашего L.

<img width="1483" height="556" alt="image" src="https://github.com/user-attachments/assets/f3461a50-64ad-41cd-a194-b205573cf6f7" />

Проверка принадлежности слову из L состоит из двух частей:

1. Условие “w1 не содержит aa” — локальное: достаточно помнить, был ли предыдущий символ равен a.
Это реализуется через сосотояния q0 и q1 .

2. Условие равенства |w1|<sub>a</sub> = |w2|<sub>b</sub> — это баланс “количество a в первой части” равно “количество b в последней части”. 
Для этого используется стек:
- в начале стека лежит маркер дна ⊥, обозначающий конец стека.
- за каждую букву a, прочитанную в w1, кладём маркер A в стек;
- за каждую букву b, прочитанную в w2, снимаем один маркер A со стека;
- в конце стек должен вернуться к ⊥. 

Т.к. границы разбиения w = w1 a^n w2 заранее неизвестны (в слове нет разделителей), то автомат недетерминированно выбирает границы с помощью переходов без чтения входа (ε-переходов).<br>
Таким образом наш автомат получая на вход слово, одновременно проверяет все возможные разбиения слова, и если одно из условий нарушается то ветка это разбиения заершается, если из всех возможных разбиений хотябы одно достигает состояния qAcc, то атомат принимает слово.<br>
Действительно если хотябы одно из разбиений слова удовлетворет условиям, то оно принадлежит языку.
Опишем Конструкцию НПДА

Входной алфавит: {a, b} <br>
Алфавит стека: {⊥, A}, где ⊥ — маркер дна стека. <br>

Состояния: <br>
q0   — читаем w1, предыдущий символ не равен a (или начало слова) <br>
q1   — читаем w1, предыдущий символ равен a (контроль запрета aa) <br>
qM   — читаем середину a^n <br>
q2   — читаем w2 <br>
qACC — принимающее состояние <br>

Если слово принято, значит существует ветка вычисления, где автомат выбрал разбиение w = w1 a^n w2.
В фазе w1 запрет aa обеспечен отсутствием перехода по a из q1.
Каждая a в w1 добавляет один A в стек.
В фазе w2 каждая b снимает один A, а принять можно только при возврате к ⊥.
Следовательно, |w1|<sub>a</sub> = |w2|<sub>b</sub>, и слово удовлетворяет определению L.

Если слово принадлежит L, то существует корректное разбиение w = w1 a^n w2.
Автомат недетерминированно выбирает границы именно в этих позициях,
затем корректно проверяет отсутствие aa в w1 и баланс стека между a в w1 и b в w2,
поэтому существует принимающая ветка.
Следовательно, слово будет принято.

Итак, язык L распознаётся НПДА, значит L является контекстно-свободным.

Теперь проверим язык на детерминизм.

Рассмотрим регулярный язык
R = (ab)* aa b*.
Положим K = L ∩ R.

Любое слово из R имеет вид w = (ab)<sup>t</sup> aa b<sup>m</sup>, t,m ≥ 0.
Так как w<sub>1</sub> не должно содержать подслово aa, граница между w<sub>1</sub> и a<sup>n</sup> в словах из R может проходить относительно блока “aa” только двумя способами:

w<sub>1</sub> = (ab)<sup>t</sup>, тогда a<sup>n</sup> = aa (то есть n = 2), w<sub>2</sub> = b<sup>m</sup> и условие |w<sub>1</sub>|<sub>a</sub> = |w<sub>2</sub>|<sub>b</sub> даёт m = t.

w<sub>1</sub> = (ab)<sup>t</sup>a, тогда a<sup>n</sup> = a (то есть n = 1), w<sub>2</sub> = b<sup>m</sup> и условие даёт m = t+1.

Следовательно,
K = { (ab)<sup>t</sup> aa b<sup>t</sup> | t ≥ 0 } ∪ { (ab)<sup>t</sup> aa b<sup>t+1</sup> | t ≥ 0 }.

Предположим, что L ∈ DCFL. Тогда и K ∈ DCFL, поскольку класс DCFL замкнут относительно пересечения с регулярными языками.

Покажем, что K не может быть распознан никаким ДПМА. Рассмотрим момент чтения первой ‘a’ из блока “aa” после префикса (ab)<sup>t</sup>. Для принятия слова (ab)<sup>t</sup> aa b<sup>t</sup> автомат должен интерпретировать эту ‘a’ как принадлежащую середине a<sup>n</sup> (не увеличивать счётчик |w<sub>1</sub>|<sub>a</sub>), а для принятия (ab)<sup>t</sup> aa b<sup>t+1</sup> — как принадлежащую w<sub>1</sub> (увеличить |w<sub>1</sub>|<sub>a</sub> на 1). Эти два требования взаимоисключающие, а после “aa” остаются только символы b, поэтому “исправить” выбор позже невозможно. Значит, детерминированный автомат не может принимать обе семьи слов, то есть K ∉ DCFL.

Получили противоречие. Следовательно, L ∉ DCFL, то есть язык L не детерминизируем.

# задача 3:
Дан язык, заданный атрибутивной грамматикой: <br>
S → SAAS   ; A1.b == A2.b <br>
S → ASA    ; A1.b == A2.b <br>
S → aba <br>
A → aA     ; A0.b := A1.b <br>
A → bA     ; A0.b := A1.b + 1 <br>
A → a      ; A.b := 0 <br>

Заметим что : <br>
1. Нетерминал A порождает слово из {a,b}<sup>*</sup>, которое обязательно оканчивается на a. <br>
2. Значение A.b равно количеству символов b в этом порождённом слове. Т.к. правило A→bA увеличивает счётчик b на 1, правило A→aA не изменяет счётчик, а база A→a задаёт b=0. <br>

## проверка на КС:

Чтобы доказать, что язык является контекстно-свободным, построим НПМА, который имитирует выводы S и проверяет условия A<sub>1</sub>.b == A<sub>2</sub>.b с помощью стека.

<img width="2293" height="719" alt="image" src="https://github.com/user-attachments/assets/40ff8b0b-2232-4f1a-b866-430f10e9cb6a" />


Автомат имитирует выводы нетерминала S, выбирая одно из трёх правил: <br>

1) S → aba  <br>
2) S → ASA при условии равенства числа `b` в двух подсловах A  <br>
3) S → SAAS при условии равенства числа `b` в двух подряд идущих подсловах A  <br>

Проверка условий равенства реализуется стеком:<br>

- перед чтением пары A…A в стек кладётся маркер `M` (граница сравнения); <br>
- при чтении первого A за каждый символ `b` кладём в стек маркер `X` (то есть “считаем” `b`); <br>
- при чтении второго A за каждый `b` снимаем один `X`; <br>
- завершить второе A можно только если на вершине снова `M`, то есть `X` полностью сняты, а значит числа `b` совпали; <br>
- затем `M` снимается, и автомат продолжает разбор. <br>

Алфавит стека: {⊥, rEND, rASA, rS1, rS2, M, X}, где ⊥ — маркер дна стека. <br>

Для сокращения добавленны переходы вида “σ, Z→Z” означают, что вершина стека неважна (Z — любой символ вершины) и не изменяется.<br>
Состояния: <br>
- qInit — инициализация, кладём `rEND` над ⊥ и переходим к разбору S  <br>
- qS — выбор продукции для S (недетерминированно)  <br>
- qBase0, qBase1, qBase2 — реализация S → aba  <br>
- qASA0..qASA4 — реализация S → ASA и проверка A<sub>1</sub>.b == A<sub>2</sub>.b  <br>
- qSAAS0..qSAAS5 — реализация S → SAAS и проверка A<sub>1</sub>.b == A<sub>2</sub>.b для двух подряд идущих A  <br>
- qAcount — чтение A в режиме подсчёта `b` (push `X` на `b`)  <br>
- qAmatch — чтение A в режиме сопоставления (pop `X` на `b`)  <br>
- qRET — возврат из рекурсивных вызовов S по маркерам `rASA`, `rS1`, `rS2`  <br>
- qACC — принимающее состояние <br>

Если слово принято, значит существует ветка вычисления, где автомат выбрал последовательность правил для S, соответствующую некоторому дереву вывода. Для каждого применения правил S → ASA или S → SAAS автомат проверяет равенство числа `b` в паре подслов A…A с помощью стека (маркеры `M` и `X`). Поэтому все атрибутивные условия A<sub>1</sub>.b == A<sub>2</sub>.b выполнены, и слово принадлежит языку грамматики.
Если слово принадлежит языку, то существует корректное дерево вывода, удовлетворяющее всем условиям равенства. Автомат недетерминированно выбирает те же правила S и те же границы подслов A, а стековая проверка равенства `b` в каждой паре A проходит успешно, поэтому существует принимающая ветка.
Построен НПМА, распознающий язык данной атрибутивной грамматики => язык является КС.

## проверка на регулярность:
Рассмотрим регулярный язык <br>

R<sub>0</sub> = b<sup>*</sup> a a b a b<sup>*</sup> a. <br>

Он регулярный, так как задаётся регулярным выражением (замкнутость регулярных языков относительно звезды Клини и конкатенации).<br>

Рассмотрим пересечение <br>

K = L ∩ R<sub>0</sub>. <br> 

Если бы L был регулярным, то и K был бы регулярным, потому что класс регулярных языков замкнут относительно пересечения. <br>
Покажем, что <br>

K = { b<sup>n</sup> a a b a b<sup>n</sup> a  |  n ≥ 0 }. <br>

Внутри грамматики можно применить правило S → ASA и в качестве среднего S взять базу S → aba. Следовательно 

S ⇒ ASA ⇒ A (aba) A.

- Язык A состоит из строк над {a,b}, оканчивающихся на `a`.
  Регулярное ограничение R<sub>0</sub> заставляет оба A иметь вид **только** b<sup>*</sup>a,
  то есть A<sub>1</sub> = b<sup>n</sup>a и A<sub>2</sub> = b<sup>m</sup>a.
- Атрибутное условие A<sub>1</sub>.b == A<sub>2</sub>.b означает n = m.

Значит, в пересечении остаются ровно слова вида b<sup>n</sup> a a b a b<sup>n</sup> a.

Предположим, что K — регулярный язык. Тогда существует длина накачки p.

Возьмём слово

w = b<sup>p</sup> a a b a b<sup>p</sup> a ∈ K.

Разложим w = xyz так, что |xy| ≤ p и |y| > 0.
Тогда x и y состоят только из символов `b` из первого блока b<sup>p</sup>, то есть y = b<sup>k</sup>, где k > 0.
Накачаем i = 0:

xz = b<sup>p-k</sup> a a b a b<sup>p</sup> a.

В слове xz число `b` слева от подслова `aaba` равно p-k,
а число `b` справа равно p. Они не равны, значит xz ∉ K.

Получили противоречие лемме о накачке для регулярных языков.
Следовательно, K не регулярный.
Так как K = L ∩ R<sub>0</sub> не является регулярным, а пересечение регулярного языка с регулярным языком всегда регулярно,
то L не может быть регулярным.
## Вывод:
Значит язык КС, но не регулярный 
