# Отчет по анализу системы переписывания

## Исходная система правил (SRS):
bb → d<br>
bb → c<br>
cc → cddc<br>
ddd → ac<br>
aa → bc<br>
bc → abba

## Переименованная система (d = s):
Для удобства восприятия и записи переименуем *d* в *s* (d = s) и дальше будем работать в системе: <br>
bb → s<br>
bb → c<br>
cc → cssc<br>
sss → ac<br>
aa → bc<br>
bc → abba 

## Завершимость

Исходя из правил можно заметить, что все кроме правила переписывания bc → abba требуют пару/тройку одинаковых символов тогда:

**1.** Рассмотрим отдельную часть какого-то случайного слова, которая состоит из одинаковых символов стоящих рядом:
... x<sup>n</sup>... 
Теперь рассмотрим частые случаи возможных различных значений x = {a, b, c, s}

**1.1.** Если x = c => 
   - при n = 1: c - НФ,
   - при n > 1: (x)^n = с<sup>n</sup> → (css)<sup>n</sup> c - НФ

где правило cc → cssc применяется однозначно и не зависит от последовательности выбора пары *cc*, т.к. по сути любая пара *cc* разделяется *ss* и к полученной последовательности символов никакие другие правила не применимы.

=> Количество подряд идущих пар символов cc уменьшается с каждым применением правила на 1 и в итоге окажется 0 в рассматриваемой последовательности.

**1.0.** Из приведенной системы правил не последовательностью одинаковых символов является только правило bc → abba. Тогда необходимо отдельно рассмотреть последовательность bc и все ее ключевые точки коих 3:

```
   bbc → (c|s)c
        ↙      ↘
      cssc       sc
   bc → abba → a(c|s)a
   bcc → bcssc → abbacssc → a(c|s)acssc
```

Т.е. bc однозначно преобразуется в конечное сочетание символов, начинающихся на {c, s или a} и заканчивающихся на {c или a}.

Заметим, что к другим парам, состоящим из различных букв стоящих рядом, правила не применимы и можно назвать их "завершимыми".

**1.2.** если x = s: <br>
s<sup>n</sup> → s<sup>3k</sup>ss → sss<sup>k</sup>ss → (ac)<sup>k</sup>ss <br>
s<sup>n</sup> → s<sup>3k</sup>s → sss<sup>k</sup>s → (ac)<sup>k</sup>s <br>
s<sup>n</sup> → s<sup>3k</sup> → sss<sup>k</sup> → (ac)<sup>k</sup> <br>
причем тут {s, ss} так же может лежать между пар *ac*, но последовательность s<sup>n</sup> так же будет завершенной, так как правила не применяются к сочетаниям букв *ac* или *s*.

**1.3.** если x = a: <br>
рассмотрим аа → bc → abba → a(c|s)a <br>
аналогично 1.1. любая пара *аа* разделяется (c|s) => количество подряд идущих пар символов *aa* уменьшается с каждым применением правила и в итоге окажется 0 в рассемой посматриваледовательности <br>
или <br>
a<sup>n</sup> → a((c|s)a)<sup>n</sup> <br>
=> последовательность из *a* тоже завершима


**1.4.** если x = b: <br>
т.к. bb → s или bb → c то рассмотрев отдельно последовательность b<sup>n</sup> = bb...b от начала и до конца мы получим завершенную последовательность так как любые правила применимые к *b* в конечном итоге уменьшают их количество <br>
bb → s -2b<br>
bb → c -2b<br>
bc → abba → a(c|s)a -1b<br>
где даже aa → bc хотя и добавляет 1b но потом *bc* однозначно превращается в a(c|s)a так как 
даже <br> асс → bcc → bcssc → abbacssc → a(c|s)acssc<br>
то есть из всех предыдущих пунктов можем заключить что даже появившиеся вследствии неких преобразований новых последовательностей внутри изначального cc → cssc будут уменьшаться подряд идущие b <br>
bbb → bc → a(c|s)a <br>
bbb → cb <br>
bbb → bs <br>
bbb → sb <br>
В итоге останется конечное число подряд идущих различных символов без повторов кроме *ss*, но для применения к последовательности из *s* какого-либо правила надо чтобы у него было больше трех *s*, а это возвращает в случай 1.2.
то есть наша изначальная b<sup>n</sup> станет завершенной и конечной <br>


**2. Основная идея**
мы можем разбить любое слово *w* конечной длины, на конечное число подряд идущих последовательностей одинаковых символов <br>
*w* = [__x<sup>k<sub>1</sub></sup>__][__x<sup>k<sub>2</sub></sup>__][__x<sup>k<sub>3</sub></sup>__]...[__x<sup>k<sub>n</sub></sup>__] <br>
где k<sub>i</sub> >= 1 и если k<sub>i</sub> = 1 то к нему правила не приминемы ибо, иначе k<sub>i</sub> > 1 то по пунктам **1.** они будут однозначно завершимы, после подобных преобразований у нас получится новое *w* без возможности применения прваил внутри k<sub>i</sub>.<br>
Но на стыках k<sub>i</sub> и k<sub>i+1</sub> тоже могут применяться правила 
однако этих стыков уже будет n-1 (аналог с бревном которое пилят пилой, где количество частей на 1 больше чем распилов, вот и у нас проблемные зоны это распилы но их на 1 меньше). то есть мест где можно было применить правила с n уменьшилось до n-1, теперь аналогично рассмотрим эти промежутки где приминимо либо правило bc→ a(c|s)a или другое сочетание различных букв(но из 1.0 =Ю и к ниим правила не применишь), либо подряд идущие символы которые аналогично завершимы из пунктов 1. И так количество проблемных мест будет уменьшаться пока не станет равно 0, а значит мы получим слово к которому не применимы правила. ТАДАМ система завершима (p.s. не лучший способ, но интересный).

## Конечность классов эквивалентности по НФ
### Основа - классов бесконнечное колличество 
Если учитывать строгость определения НФ:<br>
Терм находится в нормальной форме, если он не содержит ни одного редекса. Редекс — это подтерм, который можно унифицировать с левой частью некоторого правила системы.<br>
Т.е. НФ это любое слово к которому нельзя применить правило, тогда учитываются и те термы которые нельзя получить результатом правил.
Рассмотрим последовательность классов эквивалентности (ab)<sup>k</sup> - бесконечная, т.к. k бесконечная.<br>
Мы получили смежные классы вида *ab*, *abab*, *ababab*, ... (ab)<sup>k</sup> и их бесконечно, однако не применимы ни правые и ни левые части правил т.е. их нельзя получить.
### дополнительно
Но давайте рассмотрим конечность классов эквивалентности внутри системы, которые можно получить результатом каких-то правил.
У нас есть SRS:<br>
bb → s<br>
bb → c<br>
cc → cssc<br>
sss → ac<br>
aa → bc<br>
bc → abba <br>
Для которой по условию правила работают в обе стороны и при наличии bb↔s и bb↔c => c↔s можно сделать ввывод, что c=s тогда система приобретает новый вид:<br>
bb → c<br>
cc → cccc<br>
ccc → ac<br>
aa → bc<br>
bc → abba <br>
давайте разберемся с новой системой:<br>
**1**<br>
cc ↔ cccc => c<sup>2n</sup> ↔ cc т.к можем от cc сколько угодно +/- 2с пока n>1<br>
**2**<br>
рассмотрим цепочку неочевидных преобразований <br>
aa ↔ bc ↔ abba ↔ aca<br>
bc ↔ **ac**a ↔ ccca<br>
bc ↔ bbb <br>
bbc ↔ bbbb ↔ cbb<br>
bbb ↔ bc <br>
bc ↔ bbb ↔ cccccc ↔ cc<br>
ccc ↔ b**bc**c ↔ **bc**cc ↔ cccc ↔ cc<br>
=> c<sup>n</sup> ↔ cc (при n > 1) или с (при n=1)<br>
aa ↔ bc ↔ cc<br>
aaa ↔ bca ↔ ccca ↔ bc ↔ аа<br> =><br>
**3** a<sup>n</sup> ↔ aa (при n > 1) или a (при n=1), где аа ↔ сс<br>
bbb ↔ bc ↔ cc ↔ bbbb<br> =><br>
**4** b<sup>n</sup> ↔ bbb (при n > 2) или bb (при n=2) или b (при n=1), где bbb ↔ сс<br>


**уточнение** <br>
пусть для x<sup>k</sup> ↔ cc верно, тогда и верно b<sup>k+1</sup> ↔ сс
если xxx ↔ xxxx для k >3 т.к. берем просто последние xxx 
аналогично для k > 2 достаточно xx ↔ xxx и т.д.
отсюда по индукции следует суждение 3 и 4


**5**
рассмотрим множествво смежных классов <br>
E, c, b, a, cc, ca, (ab)<sup>n</sup>, b(ab)<sup>n</sup>, a(ba)<sup>n</sup>, (ba)<sup>n</sup><br>
**5.1** Тогда любое слово в котором чередеуются *a* и *b* подходит в последние 4 класса, если  чередование нарушится, и  пояится последовательность аа или bb, то они обратяться в *с* или *сс* и слово схлопнется в *сс* Т.к. *с* в сочетании с *b* может сделать любое сочетание букв при достатычном коллчестве букв.<br>
**5.2** Даайте разберем случаи нехватки букв:
a - NF<br>
b - NF<br>
c ↔ bb - класс эквивалентности<br>
aa ↔ cc - класс эквивалентности<br>
ab - NF<br>
ac ↔ cc - класс эквивалентности<br>
bb ↔ cc - класс эквивалентности<br>
bc ↔ cc - класс эквивалентности<br>
ba - NF<br>
cc  - класс эквивалентности<br>
ca ↔ bba - класс эквивалентности<br>
cb ↔ bbb ↔cc - класс эквивалентности<br>
дальше троики из *а* и *b* уже рассмоттрены в **5.1**




